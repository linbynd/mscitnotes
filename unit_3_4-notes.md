
#Unit 3
##1.	Explain the process of software development. 

###The Process of Software Development 
A software development process or a life cycle is a disciplined approach to develop a software product. There are various models that explain the activities or tasks that happen during the process. 
The software development process can be categorized into a number of sub-processes. Each sub-process needs to have the following information: 
	
- A description about how the software works.
- Specification of the input needed for the process.
- Specification of the output to be generated. 

The software development process can also be looked upon as a series of transformations where the output of a particular phase becomes the input for the next phase. We can explain the series of transformations that takes place in three different phases: 

**1) Analysis** – In this phase, the system analyst collects the details of the problem, interacts with the user of the system to find out the user requirements and analyzes the system to understand the functioning. Based on this study, the analyst prepares a model of the desired system. This model is purely based upon what the system is expected to do. At this stage the implementation details are not considered. Only the model of the system is prepared based on the idea that the system is made up of a set of communicating objects. Importance is given to the main building blocks of the system. 

**2) Design** – This phase begins with the problem statement and concludes with a detailed design that can be converted into a functional system. This conversion covers the details of software development, description of how the software is built, description of the software development and also the testing phase. 

**3) Execution** – During this phase, the class objects and the inter- relationships of these classes are translated and actually coded using the programming language decided upon. The databases are constructed and the complete system is given a functional shape with adequate testing. 



##2.	How is high quality software built?  
In the previous section we studied about the process of software development. In this section we will discuss the process of developing good quality software.There are certain standards and models which specify how good software has to be developed. They provide a good platform for evaluating and improving the software code. Here, implementation and design details are excluded. The standards and the models developed for the software serve as an excellent medium between the developers and the end users. Analyzing the software specification is very important and also cost effective. Identifying and correcting bugs in the specification is much better than doing it in the code.High quality products that are free of errors satisfy user requirements. There are basically two ways to perform system testing. We can actually test a system according to how it is built or what the system has to do. Correspondence, correctness; verification and validation define these approaches.
- Correspondence – Correspondence defines how the system developed can adapt to its functioning environment.- Correctness – Correctness determines if the product requirements are consistent with respect to the system specifications.- Verification – Verification is a process which determines whether a system is functioning according to the requirements specified and meeting the organization’s goal Verification is usually performed at the end of the project.- Validation – Validation is a process in which all the technical specifications, consistency and the adherence to standards of the system are checked. Validation is done when the project commences but verification can be done only after the acceptance of the specifications. Validation ensures that the right product is developed whereas verification ensures that the product is developed in the right manner.

Verification and validation are very much different from each other and are independent as well. We can definitely create a product according to the specification. But if the specification is itself inaccurate, we cannot develop the correct product. A product may also be definite in its form but may not satisfy the user’s needs. After many years a product may be developed that corresponds to the original design statement but may not match with the current technology trends and the way the system operates.


##3.	Explain the method of object oriented design.  
### Object-Oriented designObject oriented design is a strategy where designers work based upon objects rather than operations or functions. The operational system which is designed is made up of objects which have their own state of functioning. The information about the functioning is hidden here and hence offers security for other parts of the system. Object oriented design is an essential part of object oriented development.Object oriented design and object oriented analysis are separate entities. Object oriented design is concerned with developing object oriented model of a software system to identify the desired requirements.The guidelines given below tell us how to develop a good object-oriented design:- Study and have knowledge about the existing class library- Current system reusage must be known- If existing classes are not suitable, create new ones so that they can be reused often.- Ensure that classes are very simple even if their number increases- Ensure that the developed attributes and methods are reusable

##4.	Explain the concept of prototyping.

The system characteristics are clearly explained in object-oriented analysis and design, but constructing a prototype for the key elements is very much essential after the products are chosen.
 
 Prototyping is an approach to the development of a system where software simulates the aspects of an actual processing system. In simple words, prototyping can be called as a shorter version of a working system. Iterative approaches are followed here to implement prototypes. Prototypes help system designers to build information systems that are easy to manipulate for end users. Prototyping is an active part of the analysis phase in the systems development life cycle. A prototype which satisfies the user can be used to identify the actions for the use cases of the prototype. A prototype must be built keeping the user in mind.
 
 Prototyping occurs in many forms, it may vary from basic sketch designs to paper screens from which users and developers can gain large amount of information. Prototyping is also used to collect user feedbacks in certain computer systems. As the initial prototype is refined in stages and becomes more aligned with the application requirements, additional details can be added to the application. With further testing, and rebuilding we can ensure that the application is within the framework of the prototype. Prototyping helps the developer to test and refine the user interface and specifications and enhance the usability of the system.

##5.	What is component based development? 
### Component Based DevelopmentComponent Based Development (CBD) offers a radically new approach to the design, construction, implementation and evolution of software applications. Software applications are built by gathering components from a variety of sources. The components themselves may be written in several programming languages and executed on different platforms.
Component based software development (CBD) mainly deals with building large software systems by integrating previously existing components. By enhancing the flexibility and maintainability of these systems, this idea can potentially be used to reduce software development costs, assemble systems rapidly, and reduce the maintenance burden associated with the support and upgrade of large systems.Today, software components are designed and tested in-house. Component based manufacturing makes all products visible for the market. For example the CAD application helps mechanical engineers to develop several prototype models for cars which can be manufactured. Every operation and modification can be done by a single click of the mouse. Similarly, Component based development (CBD) is a mechanized approach to the software development process. We can customize application development by the integration of pre-built, reusable, pre-tested software elements that function with each other. The two basic ideologies of component based development are as follows:
1. The application development can be improvised consistently if applications are assembled quickly from pre-fabricated software elements.2. A huge collection of interpretable software must be made available to developers.


##6.	What is incremental testing? 
###Incremental testingIncremental testing is a form of iterative test model. Here the test is performed by using a series of increments. A final tool is developed after a series of increments. Information is gathered from users of software and increments are done based on this.We can perform incremental testing in the following two ways:  1. Top-Down approach – In this approach, the main module is connected to the sub-modules and the stubs are used to replace the coordinated modules. Testing is done for each sub-module in an incrementalmanner. 2. Bottom-Up approach – Here the low level components are connectedas clusters. The test driver (which is a program code) is used and testing is done on the clusters one by one.

##7.	What is reusability? How is it useful?  
Reusability is one of the major benefits associated with object oriented system development. It is also one of the most difficult tasks to deliver. If an object has to be made reusable, more efforts are required to design it. For the object to be delivered, development team must have up-front time to plan reusability into the project. Reusability makes the job of development clear, more reliable, reduces time and cost, and improves consistency. Existing software elements can be effectively evaluated if the following questions are answered for the intended applications:
- Has my problem partially been solved?- Has my problem completely solved?- How have similar problems been addressed before?For these questions to be answered, detailed information about the software components is required. The reuse strategy can be promoted by the following measures:- Re-usable objects and codes must have a standard for naming andstoring attributes
- Object repository must be present to store objects with suitable security measures- Management must encourage a reuse philosophy- Analysts and developers must identify reusable objects in the currentsystems. They must also design or develop objects so that they can be reused in the long run.
The common reuse principle helps in deciding the classes that must be placed in a package. The classes in a package are always reused together. Reusable classes work with other classes that are a part of reusable abstraction.The enhanced reusability of object-oriented code also increases its reliability. A class taken from a library is likely to have explored its way into a variety of different applications and programs. The more the code is being used, the more likely that the problems will be encountered and fixed. Bugs that appear to be strange and difficult to find in our program might already have been located and eliminated.


#Unit 4
##1. Explain the different types of object oriented methodologies?
###Types of Object Oriented Methodologies
Let us now discuss the different types of object oriented methodologies in this section.We know that there are many methodologies available for system development. Every method is based on solving the business problems and applying the solution in an object oriented manner. There are some differences in documenting and sorting the information, and in the language used in these methods. We can execute an application in various methods to meet the same requirements and functionality. The main difference we notice here is in the tradeoffs and design decisions made. When two applications designed and produced using the same method look different, it does not mean that one is correct and the other is wrong. In this section let us discuss some methodologies developed by Rumbaugh, Booch and Jacobson.Every method here has its own strength. For example, the Rumbaugh method describes the object model, the Booch method gives object oriented models in detail and the Jacobson method produces user driven analysis model. Let us first discuss the Rumbaugh methodology.
##2. Explain the OMT dynamic model in detail.
OMT gives a complete and detailed dynamic model, which depicts states, transitions, actions and events. Figure 4.3 shows the OMT state transition diagram of a railway reservation system.￼
The state changes take place when one state receives any event. Depending on the present state and event the next state change takes place. For example in the figure 4.3, when a user logs into the irctc (Indian Railway Catering and Tourism Corporation) website, which is a event, only then the state changes and the user can select the train and then check for the availability of seats which is another event after which the user can book the ticket. This changes the state to enter payment details. On receiving payment details, the state enters the confirmation event.##3. Explain the micro development process of the Booch model.Booch methodologyThis is the broadly used method for system designing. It includes the analysis and design phase of an object oriented system.Booch method speaks both about logical and physical view of the object oriented design. Booch method uses many diagrams like the class diagrams, object diagrams, module diagrams, state transition diagrams, interaction diagrams and process diagrams. Let us now discuss some of these diagrams.
- ***The class diagram*** – It gives the structure of the class using classes, the relationship between them and class utilities. Figure 4.6 explains the class diagram for a fee collection system. It has two different classes that is the Student and Fees class. The Fees class inherits properties like course and other details from the Fees details class. Payment is an abstract class which has three sub classes viz., Card, Cash and Check which shows the type of payment.- ***The object diagram*** – An object diagram is a UML structural diagram that shows the instances of the classes. Figure 4.7 gives the object diagram for student class. The instance of the class students has the attributes as Ram for first name, Kumar for last name and 70, 68 and 97 as scores.- ***The module diagram*** – It depicts the allocation of classes, and objects to modules in the physical design of a system.- ***The process diagram*** – This is a graphical representation of the business process flow. Figure 4.8 shows the process diagram for mobile alarm system. The process starts with the ringing of the alarm. If we want to get up we switch off the alarm and then continue with the next step and the process ends; else we press the snooze button and after some time the process reoccurs.- ***The state transaction diagram*** – It is used to show the state space of a class, the action that causes the change of one state to another.
The Booch methodology recommends a macro and micro development process. The micro process signifies mainly the day to day activities of the developers. The four major activities of the micro process are:- To identify classes and objects to some level of abstraction- To identify the semantics of the objects and classes- To identify the relationships among classes and objects- Implementing classes and objectsThe macro process is used for controlling the micro process. The main idea of this process is to technically manage the system. It deals with the activities for the entire development team on weekly or monthly basis. The five major phases of this process are:- ***Conceptualization*** – In this phase the core requirements of the system are determined.- ***Analysis*** – In this phase a model of the preferred action is developed.- ***Design*** – In this phase an architectural plan of the system is generated.- ***Evolution*** – In this phase the implementation is developed.- ***Maintenance*** – In this phase the post-delivery processes are handled.With the micro and macro process we complete the Booch methodology. Let us next discuss another object oriented methodology namely, Jacobson methodology.##4. Define patterns of object oriented analysis and design. List the different types of patterns.***Patterns:*** 
 In the previous section you studied about different object oriented methodologies. In this section we will look at patterns in object oriented analysis and design.Riehle and Zullighoven define patterns as follows:“A pattern is a instructive information that captures the essential structure and the insight of a successful family of the proven solutions to a recurring problem that arises within a certain context and system of forces.”Christopher Alexander, a building architect, in 1970s invented the design patterns. Computer professionals soon implemented this in object oriented concepts. 
Now patterns are largely being used in system design and software architecture, and in the process of software development.The major reason for using patterns is to document and communicate the solutions for recurring problems. Documenting the pattern gives us the suitable context and the constraints and forces that may affect the solution of a problem. We can classify patterns based on the nature of these components.Patterns give a general solution to a collection of iterative problems with many restrictions. Patterns not only identify the solution but also explain why the solution is required.Coplien elucidates that a good pattern has the following features:- It solves a problem-  The concept here is proven and is not based on a theoretical aspect-  Patterns generate a solution indirectly-  It depicts the relationship of the system structures-  Patterns are aesthetic and usefulInitially many patterns concentrated on design problems but currently the patterns focus more on software engineering and software development process.The two types of patterns are:
- Generative patterns- Non generative patterns***Generative patterns***These are patterns that not only explain solutions to problems but also help us generate something and examine the final architecture that we designed. They depict the features of a good pattern and help in creating them.***Non generative patterns***These patterns are constant and inactive. They explain the iterative occurrence of a problem without knowing how to duplicate them.According to Alexander the most useful pattern are the generative patterns as they create designs which can be dynamically modified to satisfy the changing needs and demands of the user.
The implementation of many patterns, where each pattern has its own problem and forces, helps in finding a better solution and discarding the less significant solutions.##5. What is the unified approach?
###Unified ApproachIn the previous section you studied about the patterns, types of patterns and anti patterns. In this section we will explain the unified approach.We have seen so far that the methods proposed by Booch, Rumbaugh and Jacobson tried to combine their models. The unified approach determines the combined framework of their work using UML to explain the model and software development process documentation. The plan of unified approach is not to develop another methodology, but to combine the best practices from each method with UML notations and diagrams for better understanding of the object oriented concept.The steps of unified approach is divided into four parts viz, analysis, design, prototyping and testing.- In analysis phase, the static class diagram that represents the system isobtained.- In design phase, the class diagram is improved by adding more details like attributes and methods used for application.- Prototyping and testing is a continuous task to develop the system as per the user requirement.The processes included in the unified approach for software development are:- Identifying use cases that help in system development- Building object oriented analysis model using use cases- Building object oriented design using the analysis model- Prototyping and developing the model by incrementing- Continuous testing- Iterating the process until the system is completely developed.
The object oriented analysis model can be used for the following activities:- Identifying the classes that are relevant to the system.- Building relationship among the classes.- Developing class hierarchy- Combining similar classesAt the end of the output of object oriented design phase, we achieve thefollowing:- Classes developed in the analysis model are improved by adding attributes methods and properties.- Extending classes to object levelThe object oriented system is established using iterative steps. The design is enhanced iteratively by prototyping and testing which results in a better system. The unified approach of object oriented system development has the following phases:- Object oriented analysis- Object oriented design>1 The outputs of object oriented analysis phase are:Object oriented user based business model which includes:- Identifying users- Developing business process models- Understanding business as a system> Business model that is conveyed in use cases which includes:- Identifying use cases and goals of the system- Understanding the users job in the use cases- Illustrating use case diagram>2 Gives the details of use case in its activities>3 Identifying classes and building relationship among them to build a class diagram.The goals of the design phase are:* To put classes in the design architecture to obtain the goal of theapplication.* Organizing the system classes that have relationship among them.* Improve design by prototyping and testing.* Enhancing the system by iterating and refining* Testing the complete system for user approval
Unified approach uses UML modeling the system. UML has become the standard notation for object oriented system modeling.
